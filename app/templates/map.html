
<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
  <script src="https://d3js.org/d3.v5.min.js"></script>
  <!-- <script src='https://api.mapbox.com/mapbox-gl-js/v2.7.0/mapbox-gl.js'></script>
  <link href='https://api.mapbox.com/mapbox-gl-js/v2.7.0/mapbox-gl.css' rel='stylesheet' /> -->
  <script src="https://cdn.maptiler.com/mapbox-gl-js/v1.13.2/mapbox-gl.js"></script>
  <link href="https://cdn.maptiler.com/mapbox-gl-js/v1.13.2/mapbox-gl.css" rel="stylesheet" />

  <script src="https://d3js.org/d3.v5.min.js"></script>

  <style>
    body {
            font-family: "Helvetica Neue", Helvetica, sans-serif;
            font-size: 14px;
            color: #333;
            background-color: #bbb;
        }
    #map {height:min(70vw, 85vh); width:min(70vw, 85vh);}
  </style>
</head>
<body>
  <div>
    <h1>Floodaware Dashboard</h1>
    <p>Welcome to the development build of the Floodaware dashboard</p>
    <p>You can click on level icons to view information about the water level sensors,
        all values are in m(AHD), the scale automatically adjusts for each sensor
    </p>
    <!-- <p>
        You can also hover over the graph of the average rainfall from BOM(mm/hr)
        (currently historical data only) to update the map display of rain clouds
    </p> -->
    <div id="map"></div>
  </div>
  
  </div>
  <script>
    class Chart {
      constructor() {
        let margin = {top: 10, right: 30, bottom: 30, left: 60},
          width = 360 - margin.left - margin.right,
          height = 260 - margin.top - margin.bottom;

        this.graph = d3.select(document.createElement("div"))

        this.graph
          .append("svg")
              .attr("id", "graph")
              .attr("width", width + margin.left + margin.right)
              .attr("height", height + margin.top + margin.bottom)
          .append("g")
              .attr("transform", "translate(" + margin.left + "," + margin.top + ")")

      }

      createGraph = (data, state) => {
        let stringtodate = datestring => d3.timeParse("%Y-%m-%dT%H:%M:%S")(datestring)
        data.forEach(d => {
            d.stamp = stringtodate(d.stamp)
        })

        data = data.filter(d => d.level < 5000)

        temp = state.sensors.features.map(d => [d.properties.id, d.properties.ahd])
        ahds = Object.fromEntries(temp)

        data.forEach(d => {
            d.level = ahds[d.id] - d.level/1000
        })

        dataselected = data.filter(d => d.id == 25)
        
        let x = d3.scaleTime()
            .domain(d3.extent(data, d => d.stamp))
            .range([ 0, width ]);
        this.graph.append("g")
            .attr("id", "xaxis")
            .attr("transform", "translate(0," + height + ")")
            .call(d3.axisBottom(x));

        let y = d3.scaleLinear()
            .domain([0, d3.max(data, d => +d.level)])
            .range([ height, 0 ]);
        this.graph.append("g")
            .attr("id", "yaxis")
            .call(d3.axisLeft(y));

        this.graph.append("path")
            .attr("id", "data")
            .datum(dataselected)
            .attr("fill", "none")
            .attr("stroke", "steelblue")
            .attr("stroke-width", 1.5)
            .attr("d", d3.line()
                .x(d => x(d.stamp))
                .y(d => y(d.level))
            )
        
        this.graph.append("text")
            .attr("class", "y label")
            .attr("text-anchor", "end")
            .attr("y", 6)
            .attr("dy", "-3em")
            .attr("fill", "white")
            .attr("transform", "rotate(-90)")
            .text("Water Level Sensor Reading (mAHD)")

        updateGraph = () => {
            dataselected = data.filter(d => d.id == selectedSensor)

            y = d3.scaleLinear()
                .domain([d3.min(dataselected, d => +d.level)-0.5, d3.max(dataselected, d => +d.level)+0.5])
                .range([ height, 0 ])
            
            d3.selectAll("g #yaxis")
                .call(d3.axisLeft(y))
            
            updated = this.graph.select("path#data")
                .datum(dataselected)
                .attr("fill", "none")
                .attr("stroke", "steelblue")
                .attr("stroke-width", 1.5)
                .attr("d", d3.line()
                    .x(d => x(d.stamp))
                    .y(d => y(d.level))
                )
        }
      }
    }

    class ApiHandler {
      constructor() {

      }

      bindRadar() {

      }

      bindHotspots() {

      }

      bindLevels() {

      }

      bindRainfallAvg() {

      }
    }

    class Model {
      constructor() {
        this.radar = {}
        this.hotpsots = {}
        this.levels = {}
        this.rainfallAvg = {}
      }

      setRadar() {

      }

      updateRadar() {

      }

      setHotspots() {

      }

      setLevels() {

      }

      updateLevels() {

      }

      setRainfallAvg() {

      }

      updateRainfallAvg() {

      }
    }

    class View {
      constructor() {

      }
    }

    class Controller {
      constructor() {

      }
    }

  </script>
  <script>
    // mapboxgl.accessToken = 'pk.eyJ1IjoibmF0b2h1dGNoIiwiYSI6ImNsMW85cmxsbjEyZTQzYnM5ZXhvdm53MHoifQ.7tChnQlrKf5gGk-ATFiPGg'
    // You can remove the following line if you don't need support for RTL (right-to-left) labels:
    //mapboxgl.setRTLTextPlugin('https://cdn.maptiler.com/mapbox-gl-js/plugins/mapbox-gl-rtl-text/v0.2.3/mapbox-gl-rtl-text.js');
    
    let map = new mapboxgl.Map({
      container: 'map',
      style: 'https://api.maptiler.com/maps/topo/style.json?key=TGgOfxJrRHJvzjeiOdhm',
      //style: 'mapbox://styles/natohutch/cl1vptxmu000i16pnii0nk61a',
      center: [150.88,-34.4],
      zoom: 13,
      maxBounds: [
          [150.73,-34.49],
          [151,-34.32]
      ]
    })

    let api_endpoint = window.location.origin+"/api/"

    
    map.on("load", () => {
      map.addSource("hotspots", {
        type: "geojson",
        data: api_endpoint+"hotspots"
      })

      map.addSource("catchment", {
        type: "geojson",
        data: api_endpoint+"catchment"
      })

      map.addSource("sensors", {
        type: "geojson",
        data: api_endpoint+"sensors"
      })

      map.addLayer({
        "id": "catchment",
        "type": "fill",
        "source": "catchment",
        "paint": {
          "fill-color": "green",
          "fill-opacity": 0.11,
          "fill-outline-color": "darkgreen"
        }
      })

      map.addLayer({
        "id": "catchment-outline",
        "type": "line",
        "source": "catchment",
        "paint": {
          "line-color": "darkgreen",
          "line-width": 2,
          "line-opacity": 0.4,
        }
      })

      // let target = map.getStyle().layers[15]
      // map.moveLayer("catchment", target.id)
      // map.moveLayer("catchment-outline", target.id)


      map.addLayer({
        "id": "hotspots",
        "type": "circle",
        "source": "hotspots",
        "paint": {
          "circle-color": [
            "interpolate",
            ["linear"],
            ["get", "flood_depth"],
            -0.5,
            "yellow",
            0,
            "orange",
            3,
            "red",
            6,
            "darkred",
            10,
            "black"
          ],
          "circle-radius": 4
        }
      })

      map.addControl(new mapboxgl.NavigationControl())

      map.loadImage(
        "level_sensor.png",
        (error, image) => {
          if (error) throw error
          map.addImage("level_sensor", image, {sdf: false})

          map.addLayer({
            "id": "sensors",
            "type": "symbol",
            "source": "sensors",
            "layout": {
              "icon-image": "level_sensor",
              "icon-size": 0.05,
              "icon-allow-overlap": true,
            },
            "paint": {
              "icon-color": "blue"
            }
          })
        }
      )
    })

    // map.on("render", () => {
    //   map.resize()
    // })
      
  </script>
</body>
</html>
