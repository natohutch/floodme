
<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
  <script src="https://d3js.org/d3.v5.min.js"></script>
  <!-- <script src='https://api.mapbox.com/mapbox-gl-js/v2.7.0/mapbox-gl.js'></script>
  <link href='https://api.mapbox.com/mapbox-gl-js/v2.7.0/mapbox-gl.css' rel='stylesheet' /> -->
  <script src="https://cdn.maptiler.com/mapbox-gl-js/v1.13.2/mapbox-gl.js"></script>
  <link href="https://cdn.maptiler.com/mapbox-gl-js/v1.13.2/mapbox-gl.css" rel="stylesheet" />

  <script src="https://d3js.org/d3.v5.min.js"></script>

  <style>
    body {
            font-family: "Helvetica Neue", Helvetica, sans-serif;
            font-size: 14px;
            color: #333;
            background-color: #bbb;
        }
    #map {height:min(60vw, 75vh); width:min(60vw, 75vh);}
  </style>
</head>
<body>
  <div>
    <h1>Floodaware Dashboard</h1>
    <p>Welcome to the development build of the Floodaware dashboard</p>
    <p>You can click on level icons to view information about the water level sensors,
        all values are in m(AHD), the scale automatically adjusts for each sensor
    </p>
    <!-- <p>
        You can also hover over the graph of the average rainfall from BOM(mm/hr)
        (currently historical data only) to update the map display of rain clouds
    </p> -->
    <div id="map"></div>
  </div>
  
  </div>
  <script>
    class Chart {
      constructor(
        yAxisTitle = "",
        svgWidth = 360,
        svgHeight = 260,
        margin = {top: 10, right: 30, bottom: 30, left: 60}
      ) 
      {
        this.margin = margin
        this.width = svgWidth - margin.left - margin.right
        this.height = svgHeight - margin.top - margin.bottom
        this.yAxisTitle = yAxisTitle

        this.graph = d3.select(document.createElement("div"))

        this.graph
          .append("svg")
              .attr("id", "graph")
              .attr("width", this.width + this.margin.left + this.margin.right)
              .attr("height", this.height + this.margin.top + this.margin.bottom)

        this.group = this.graph.select("svg")
          .append("g")
              .attr("transform", "translate(" + this.margin.left + "," + this.margin.top + ")")

      }

      createGraph = (data) => {

        this.x = d3.scaleTime()
          .domain(d3.extent(data, d => d.stamp))
          .range([ 0, this.width ])
        this.group.append("g")
          .attr("id", "xaxis")
          .attr("transform", "translate(0," + this.height + ")")
          .call(d3.axisBottom(this.x))

        this.y = d3.scaleLinear()
          .domain([d3.min(data, d => +d.level)-0.5, d3.max(data, d => +d.level)+0.5])
          .range([ this.height, 0 ]);
        this.group.append("g")
          .attr("id", "yaxis")
          .call(d3.axisLeft(this.y));

        this.group.append("path")
          .attr("id", "data")
          .datum(data)
          .attr("fill", "none")
          .attr("stroke", "steelblue")
          .attr("stroke-width", 1.5)
          .attr("d", d3.line()
              .x(d => this.x(d.stamp))
              .y(d => this.y(d.level))
          )
        
        this.group.append("text")
          .attr("class", "y label")
          .attr("text-anchor", "end")
          .attr("y", 6)
          .attr("dy", "-3em")
          .attr("fill", "white")
          .attr("transform", "rotate(-90)")
          .text(this.yAxisTitle)
      }

      updateGraph = (data) => {

          this.x = d3.scaleTime()
            .domain(d3.extent(data, d => d.stamp))
            .range([ 0, this.width ])

          this.y = d3.scaleLinear()
            .domain([d3.min(data, d => +d.level)-0.5, d3.max(data, d => +d.level)+0.5])
            .range([ this.height, 0 ])
          
          this.group.selectAll("g #xaxis")
            .call(d3.axisBottom(this.x))

          this.group.selectAll("g #yaxis")
            .call(d3.axisLeft(this.y))
          
          this.group.select("path#data")
            .datum(data)
            .attr("fill", "none")
            .attr("stroke", "steelblue")
            .attr("stroke-width", 1.5)
            .attr("d", d3.line()
                .x(d => this.x(d.stamp))
                .y(d => this.y(d.level))
              )
      }

      createGraph2 = (data) => {
                
        let x = d3.scaleTime()
            .domain(d3.extent(data, d => d.stamp))
            .range([ 0, this.width ]);
        this.group.append("g")
            .attr("transform", "translate(0," + this.height + ")")
            .call(d3.axisBottom(x));

        let y = d3.scaleLinear()
            .domain([0, d3.max(data, d => +d.avg)])
            .range([ this.height, 0 ]);
        this.group.append("g")
            .call(d3.axisLeft(y));

        this.group.append("path")
            .attr("id", "data")
            .datum(data)
            .attr("fill", "none")
            .attr("stroke", "steelblue")
            .attr("stroke-width", 1.5)
            .attr("d", d3.line()
                .x(d => x(d.stamp))
                .y(d => y(d.avg))
            )

        this.group.append("text")
            .attr("class", "y label")
            .attr("text-anchor", "end")
            .attr("y", 6)
            .attr("dy", "-3em")
            .attr("transform", "rotate(-90)")
            .text(this.yAxisTitle)
      }
    }

    class ApiHandler {
      constructor() {
        this.dateRange = {}
      }

      bindDateRange() {

      }

      async bindRadar(apiRef, setRadar, updateRadar) {
        const json = await fetch(api_endpoint+`rainfall?startdate=${this.dateRange.start}&enddate=${this.dateRange.end}`).then(response => response.json())
        //console.log(json)
        setRadar(json)
      }

      async bindHotspots() {

      }

      async bindLevels(apiRef, setLevels, updateLevels) {
        const json = await fetch(api_endpoint+`sensors/data?startdate=${this.dateRange.start}&enddate=${this.dateRange.end}`).then(response => response.json())
        setLevels(json)
      }

      async bindRainfallAvg(apiRef, setRainfallAvg, updateRainfallAvg) {
        const json = await fetch(api_endpoint+`rainfall/avg?startdate=${this.dateRange.start}&enddate=${this.dateRange.end}`).then(response => response.json())
        setRainfallAvg(json)
      }
    }

    class Model {
      constructor() {
        this.dateRange = {}

        this.radar = {}
        this.hotpsots = {}
        this.levels = {}
        this.rainfallAvg = {}

        this.onDateRangeChange = []

        this.onRadarChange = []
        this.onHotspotChange = []
        this.onLevelChange = []
        this.onSetRainfallAvg = []
        this.onUpdateRainfallAvg = []
      }

      bindDateRangeChange = (func) => {
        this.onDateRangeChange.push(func)
      }

      setDateRange = (obj) => {
        this.dateRange = obj
        for (func of this.onDateRangeChange) {
          func(this.dateRange)
        }
      }

      bindRadarChange = (func) => {
        this.onRadarChange.push(func)
      }

      setRadar = (data) => {
        this.radar = data
        for (func of this.onRadarChange) {
          func(this.radar)
        }
      }

      updateRadar = () => {

      }

      bindHotspotChange = (func) => {
        this.onHotspotChange.push(func)
      }

      setHotspots = (data) => {
        this.hotspots = data
        for (func of this.onHotspotChange) {
          func(this.hotspots)
        }
      }

      bindLevelChange = (func) => {
        this.onLevelChange.push(func)
      }

      setLevels = (data) => {
        this.levels = data
        for (func of this.onLevelChange) {
          func(this.levels)
        }
      }

      updateLevels = () => {

      }

      bindSetRainfallAvg = (func) => {
        this.onSetRainfallAvg.push(func)
      }

      bindUpdateRainfallAvg = (func) => {
        this.onUpdateRainfallAvg.push(func)
      }

      setRainfallAvg = (data) => {
        this.rainfallAvg = data
        for (const func of this.onSetRainfallAvg) {
          func(this.rainfallAvg)
        }
      }

      updateRainfallAvg = (data) => {
        this.rainfallAvg = data
        for (const func of this.onUpdateRainfallAvg) {
          func(this.rainfallAvg)
        }
      }
    }

    class View {
      constructor(map) {
        this.map = map
        this.chart = new Chart("Water Level Sensor Reading (mAHD)")
        this.chart.createGraph([])
      }

      bindClickSensor = (func) => {
        map.on("click", "sensors", e => {
          func(e)
        })
      }

      displayRainfallChart(data) {
        const stringtodate = datestring => d3.timeParse("%Y-%m-%dT%H:%M:%S")(datestring)
        const selected = JSON.parse(JSON.stringify(data))
        selected.forEach(d => {
            d.stamp = stringtodate(d.stamp)
            d.avg = (d.avg/300)*3600
        })

        const rainfallChart = new Chart("BOM Average Rainfall (mm/hr)", 720)
        rainfallChart.createGraph2(selected)
        document.body.getElementsByTagName("div")[0].append(rainfallChart.graph.node())

      }

      updateRainfallChart(data) {

      }

      displayPopupChart(e, data) {
        const coordinates = e.features[0].geometry.coordinates.slice()
        
        while (Math.abs(e.lngLat.lng - coordinates[0]) > 180) {
          coordinates[0] += e.lngLat.lng > coordinates[0] ? 360 : -360
        }

        const selected = JSON.parse(JSON.stringify(data.features.filter(d => d.id === e.features[0].properties.id).filter(d => d.level < 5000)))

        const stringtodate = datestring => d3.timeParse("%Y-%m-%dT%H:%M:%S")(datestring)
        selected.forEach(d => {
            d.stamp = stringtodate(d.stamp)
        })

        // temp = state.sensors.features.map(d => [d.properties.id, d.properties.ahd])
        // ahds = Object.fromEntries(temp)

        // data.forEach(d => {
        //     d.level = ahds[d.id] - d.level/1000
        // })

        this.chart.updateGraph(selected)
        
        new mapboxgl.Popup()
          .setLngLat(coordinates)
          .setHTML(`
            <h2>Sensor ${e.features[0].properties.id}</h2>
            ${this.chart.graph.node().innerHTML}
          `)
          .setMaxWidth(400)
          .addTo(this.map)

      }

    }

    class Controller {
      constructor(model, view) {
        this.model = model
        this.view = view

        this.view.bindClickSensor(this.handleClickSensor)

        this.apiHandler = new ApiHandler()
        this.apiHandler.dateRange = {start: "20200207", end: "20200208"}

        this.model.bindSetRainfallAvg(this.onSetRainfallAvg)
        this.model.bindUpdateRainfallAvg(this.onUpdateRainfallAvg)

        // this.apiHandler.bindRadar("", this.model.setRadar, this.model.updateRadar)
        this.apiHandler.bindLevels("", this.model.setLevels, this.model.updateLevels)
        this.apiHandler.bindRainfallAvg("", this.model.setRainfallAvg, this.model.updateRainfallAvg)

      }

      handleClickSensor = (e) => {
        this.view.displayPopupChart(e, this.model.levels)
      }

      onSetRainfallAvg = () => {
        this.view.displayRainfallChart(this.model.rainfallAvg.features)
      }

      onUpdateRainfallAvg = () => {
        this.view.updateRainfallChart(this.model.rainfallAvg.features)
      }

    }

  </script>
  <script>
    const api_endpoint = window.location.origin+"/api/"

    const map = new mapboxgl.Map({
      container: 'map',
      style: 'https://api.maptiler.com/maps/topo/style.json?key=TGgOfxJrRHJvzjeiOdhm',
      //style: 'mapbox://styles/natohutch/cl1vptxmu000i16pnii0nk61a',
      center: [150.88,-34.4],
      zoom: 13,
      maxBounds: [
          [150.73,-34.49],
          [151,-34.32]
      ]
    })
    map.getCanvas().style.cursor = 'default'

    map.on('mouseenter', 'sensors', () => {
      map.getCanvas().style.cursor = 'pointer'
    })
    map.on('mouseleave', 'sensors', () => {
      map.getCanvas().style.cursor = 'default'
    })

    window.map = map

    // mapboxgl.accessToken = 'pk.eyJ1IjoibmF0b2h1dGNoIiwiYSI6ImNsMW85cmxsbjEyZTQzYnM5ZXhvdm53MHoifQ.7tChnQlrKf5gGk-ATFiPGg'
    // You can remove the following line if you don't need support for RTL (right-to-left) labels:
    //mapboxgl.setRTLTextPlugin('https://cdn.maptiler.com/mapbox-gl-js/plugins/mapbox-gl-rtl-text/v0.2.3/mapbox-gl-rtl-text.js');

    const controller = new Controller(new Model(), new View(map))
    window.controller = controller   

    
    map.on("load", () => {
      map.addSource("hotspots", {
        type: "geojson",
        data: api_endpoint+"hotspots"
      })

      map.addSource("catchment", {
        type: "geojson",
        data: api_endpoint+"catchment"
      })

      map.addSource("sensors", {
        type: "geojson",
        data: api_endpoint+"sensors"
      })

      map.addLayer({
        "id": "catchment",
        "type": "fill",
        "source": "catchment",
        "paint": {
          "fill-color": "green",
          "fill-opacity": 0.11,
          "fill-outline-color": "darkgreen"
        }
      })

      map.addLayer({
        "id": "catchment-outline",
        "type": "line",
        "source": "catchment",
        "paint": {
          "line-color": "darkgreen",
          "line-width": 2,
          "line-opacity": 0.4,
        }
      })

      // let target = map.getStyle().layers[15]
      // map.moveLayer("catchment", target.id)
      // map.moveLayer("catchment-outline", target.id)


      map.addLayer({
        "id": "hotspots",
        "type": "circle",
        "source": "hotspots",
        "paint": {
          "circle-color": [
            "interpolate",
            ["linear"],
            ["get", "flood_depth"],
            -0.5,
            "yellow",
            0,
            "orange",
            3,
            "red",
            6,
            "darkred",
            10,
            "black"
          ],
          "circle-radius": 4
        }
      })

      map.addControl(new mapboxgl.NavigationControl())

      map.loadImage(
        "level_sensor.png",
        (error, image) => {
          if (error) throw error
          map.addImage("level_sensor", image, {sdf: false})

          map.addLayer({
            "id": "sensors",
            "type": "symbol",
            "source": "sensors",
            "layout": {
              "icon-image": "level_sensor",
              "icon-size": 0.035,
              "icon-allow-overlap": true,
            },
            "paint": {
              "icon-color": "blue"
            }
          })
        }
      )
    })

    // map.on("render", () => {
    //   map.resize()
    // })
      
  </script>
</body>
</html>
